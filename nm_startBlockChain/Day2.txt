#2.2 Types of TS part One

* optional types(선택적 변수) *

for example - define object

const player = {
  name: string,
  age?: number
} = {
  name: "nico"
}

if(player.age && player.age < 10) {

}


if we make many player(object)


* Alias(별칭) types *
makes using less code

type Player = {
  name: string,
  age?: number
}

const nico : Player = {
  name: "nico"
}
const lynn : Player = {
  name: "lynn",
  age: 12
}

Another way to use Alias

type Age = number;
type Player = {
  name: string,
  age?: Age
}

-> just using this until our code as clear


* Way to Assign return value of function's type *

result -> get nice autocomplete and protections

for example
(make function -> function make player's object -> return Player type)

function playerMaker(name:string) : Player {
  return {
    name: name
  }
}
const nico = playerMaker("nico")
nico.age = 12

+) when using arrow function, how assign playerMaker type

const playerMaker = (name: string) => ({name})
-> this code makes error because ts can't know function playerMaker
    return Player

const playerMaker = (name: string) : Player => ({name})

---------------------------------------

# 2.3 Types of TS part Two

* if we want, we can add 'readonly' property on types. *

readonly -> allow us to make property "read only"(js has no)

for example : string[]

const names: readonly string[] = ["1","2"]
names.push()

-> we can get immutability. 


* Tuple *

-> can create array, need to get a minimum length, and then get specific type in specific location 

for example

["nico", 12, false] ( just array ex )

const player: [string, number, boolean] = ["nico", 1, true]

-> remember, when we use this, we can assign array what should always get setted the number of properties.
        and get types in the order that we want
        sometiems API give us like that

player[0] = 1 // error because it is not string

+) readonly plus tuple

const player: readonly [string, number, boolean] = ["nico", 1, true]
player[0] = "hi" // error because of readonly


* Any *

when we use empty value, default becomes "any"
any -> type, when we want to escape from ts
(if want to escape from readonly)
because any can be any type

There are some rules for stop by using any 

example
const a : any[] = [1,2,3,4]
remove : any[]


