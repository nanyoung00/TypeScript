# 3.2 Polymorphism

poly : many, several, much, multi
morphos: form, structure
=> many different structure

1. recieve array and make function that print result of array

type SuperPrint = {
    (arr: number[]): void
    (arr: boolean[]): void
    (arr: string[]):void
}

const superPrint: SuperPrint = (arr) => {
    arr.forEach(i => console.log(i))
}

superPrint([1,2,3,4])
superPrint([true,false,true])
superPrint("a","b","c")

- here is example. There are three call signature and I want to make like this
superPrint([1,2,true,false])

so maybe I can do like (arr:(number|boolean)[]): void
but we have "generic"

Generic is like "placeholder" for the types
-> when we write call signature, don't know what certain type will come here, then we use generic
number, string, boolean are "concrete type"
we don't know type in advance
so when we write code and make function, use it, of course we are going to use concrete type.
we write call signature, there in some case, we don't know about concrete type.
then we use generic

* How to use Generic * 

1. tell to TS we want to use Generic

type SuperPrint = {
    <TypePlaceholder>(arr: TypePlaceholder[]): void
}

const superPrint: SuperPrint = (arr) => {
    arr.forEach(i => console.log(i))
}

superPrint([1,2,3,4])
superPrint([true,false,true])
superPrint(["a","b","c"])
superPrint([1,2,true,false])

using <>!

- another case : when we want to change return type, superPrint get array, superPrint return the first item of the array.

type SuperPrint = {
    <TypePlaceholder>(arr: TypePlaceholder[]): TypePlaceholder
}

const superPrint: SuperPrint = (arr) => arr[0]


const a = superPrint([1,2,3,4])
const b = superPrint([true,false,true])
const c = superPrint(["a","b","c"])
const d = superPrint([1,2,true,false])

---------------------------------------

# 3.3 Generics Recap


---------------------------------------

# 3.4 Conclusions